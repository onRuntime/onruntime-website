---
term: 프레임워크
shortDescription: 표준화되고 재사용 가능한 기능을 제공해서 개발을 쉽게 해주는 소프트웨어 구조
relatedTerms:
  - Library
  - API
  - React
  - Angular
  - Vue.js
  - Next.js
tags:
  - development
  - architecture
---
## 정의

프레임워크는 onRuntime의 조립된 도구 상자와 같아. 각 프로젝트마다 모든 걸 처음부터 만드는 대신 (자신의 못을 만들면서 집을 짓는 걸 상상해봐!), 우리는 좋은 출발점을 제공하고 확고한 규칙을 지켜주는 구조를 사용해.

## 큰 질문: 프레임워크 아니면 라이브러리?

우리는 이 질문을 클라이언트들로부터 자주 받아. 그래서 여기 정리해줄게:

- **라이브러리**는 특정 작업을 위한 특정 도구를 빌리는 것 같아. 너는 통제권을 쥐고 언제 사용할지 결정해.
- **프레임워크**는 자체 규칙이 있는 완전 장비가 갖춰진 작업실에 들어가는 것 같아. 그것이 어떻게 일해야 하는지를 알려줘.

"너는 라이브러리를 호출하지만, 프레임워크가 너를 호출한다"는 말이 잘 정리해줘.

## 우리가 사용하고 싶은 프레임워크

### 프론트엔드
- **React**: 기술적으로는 라이브러리지만, 그 주변 생태계(React Router, Redux 등)가 거의 프레임워크처럼 만들어. 사용자 인터페이스를 위한 우리의 1순위 선택이야.
- **Next.js**: 복잡한 웹사이트에 가장 좋아! 우리 자신의 onRuntime.com 사이트를 다시 만들 때 사용했어.
- **React Native**: 클라이언트의 모바일 앱을 위한 우리의 선택이야. Tonight Pass에 사용해봤는데 아주 좋은 결과를 얻었어.

### 백엔드
- **NestJS**: 우리는 완전히 팬이야! 구조적이고 모듈화되어 있어서 대규모 애플리케이션에서 시간을 엄청 절약해.
- **Express**: NestJS보다 가벼워서 간단한 API나 MVP에 사용해.
- **Prisma**: 완전한 백엔드 프레임워크는 아니지만 데이터베이스 관리에 있어 우리의 최애 ORM이야.

### 풀스택
- **Next.js** (다시!): API 라우트 덕분에 점점 더 풀스택 솔루션으로 사용하고 있어.
- **Redwood.js**: 몇 개 프로젝트에서 테스트해봤고 기대돼! JS 생태계에 맞춘 Ruby on Rails 같은 느낌이야.

## 우리가 모든 걸 처음부터 코딩하지 않는 이유

- **우리는 훨씬 더 빨리 간다**: 다른 사람들이 천 번 해결한 문제를 더 이상 겪지 않아
- **깔끔한 코드**: 프레임워크 규칙이 우리를 규율 있게 만들어
- **보안**: 인기 있는 프레임워크는 수천 명의 개발자들이 취약점을 추적하며 철저히 검토해
- **쉬운 온보딩**: 팀에 새로운 개발자를 통합할 때, 그들이 이미 프레임워크를 알고 있다면 신속하게 작업할 수 있어

## 프레임워크를 사용할지 (안 사용할지) 선택하는 방법

onRuntime에서 우리는 프레임워크를 좋아하지만, 맹목적으로 사용하진 않아. 초특정 마이크로서비스의 경우, 가벼운 접근 방식으로 몇 개의 라이브러리만 사용하는 걸 선호해. 예를 들어, Kartrak 애플리케이션을 위해 성능이 중요했기 때문에 더 미니멀한 접근 방식을 선택했어.

하지만 솔직히 말해, 시간에 민감한 대부분의 클라이언트 프로젝트를 위해 좋은 프레임워크는 시간을 엄청 절약해주니까 선택이 명확해!
